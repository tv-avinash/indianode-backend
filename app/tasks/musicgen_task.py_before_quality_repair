# app/tasks/musicgen_task.py

import os
import torch
import soundfile as sf
import subprocess
from PIL import Image

from audiocraft.models import MusicGen

from app.celery_app import celery_app
from app.services.job_store import job_store
from app.services.audio_postprocess_service import enhance_audio
from app.services.mastering.mastering_service import master_audio   # üî• NEW


# -------------------------------------------------
# Paths
# -------------------------------------------------
BASE_DIR = os.path.dirname(
    os.path.dirname(
        os.path.dirname(__file__)
    )
)

OUTPUT_DIR = os.path.join(BASE_DIR, "outputs")
os.makedirs(OUTPUT_DIR, exist_ok=True)

FFMPEG = "/usr/bin/ffmpeg"


_MODEL = None
_MODEL_NAME = None


# -------------------------------------------------
# Load model once (MODE AWARE)
# -------------------------------------------------
def load_musicgen(mode: str):
    global _MODEL, _MODEL_NAME

    target_model = (
        "facebook/musicgen-small"
        if mode == "classical"
        else "facebook/musicgen-large"
    )

    if _MODEL is None or _MODEL_NAME != target_model:
        print(f"üéµ Loading MusicGen: {target_model}")

        _MODEL = MusicGen.get_pretrained(target_model)
        _MODEL_NAME = target_model

        _MODEL.set_generation_params(
            duration=10,
            use_sampling=True,
            top_k=250,
            temperature=1.0,
            cfg_coef=3.0
        )

    return _MODEL


# -------------------------------------------------
# Celery Task
# -------------------------------------------------
@celery_app.task(name="musicgen.generate", queue="gpu")
def generate_music_task(job_id: str, payload: dict):
    try:
        print(f"\nüéº Generating music | job={job_id}")

        job_store.set_running(job_id)

        prompt = payload.get("prompt", "")
        image_path = payload.get("image_path")
        mode = payload.get("mode", "cinematic")
        duration = int(payload.get("duration", 10))

        print("\n" + "=" * 60)
        print("üéØ FINAL PROMPT SENT TO MUSICGEN")
        print(prompt)
        print("=" * 60 + "\n")

        model = load_musicgen(mode)
        model.set_generation_params(duration=duration)
        duration_str = str(duration)

        # -------------------------------------------------
        # Generate RAW WAV
        # -------------------------------------------------
        with torch.no_grad():
            wav = model.generate([prompt])[0]

        wav_path = os.path.abspath(
            os.path.join(OUTPUT_DIR, f"{job_id}.wav")
        )

        sf.write(
            wav_path,
            wav.cpu().numpy().T,
            samplerate=32000,
            subtype="PCM_16"
        )

        print("‚úÖ RAW WAV:", wav_path)

        # -------------------------------------------------
        # Enhancement
        # -------------------------------------------------
        try:
            print("‚ú® Running enhancement...")
            wav_path = os.path.abspath(enhance_audio(wav_path))
            print("‚ú® ENHANCED WAV:", wav_path)
        except Exception as e:
            print("‚ö†Ô∏è Enhancement failed:", e)

        # -------------------------------------------------
        # üî• MASTERING (Reaper + Ozone)
        # -------------------------------------------------
        # Skip mastering for classical if you prefer natural tone
        if mode != "classical":
            try:
                print("üéö Running mastering (Ozone)...")

                mastered_path = os.path.abspath(
                    os.path.join(OUTPUT_DIR, f"{job_id}_mastered.wav")
                )

                wav_path = master_audio(wav_path, mastered_path)

                print("üéö MASTERED WAV:", wav_path)

            except Exception as e:
                print("‚ö†Ô∏è Mastering failed, using enhanced audio:", e)

        else:
            print("üéß Classical mode ‚Üí skipping mastering")

        # -------------------------------------------------
        # MP4 output
        # -------------------------------------------------
        mp4_path = os.path.abspath(
            os.path.join(OUTPUT_DIR, f"{job_id}.mp4")
        )

        # -------------------------------------------------
        # IMAGE ‚Üí VIDEO
        # -------------------------------------------------
        if image_path:
            image_path = os.path.abspath(image_path)

            if not os.path.exists(image_path):
                raise RuntimeError(f"Image not found: {image_path}")

            fixed_img = image_path + "_fixed.jpg"

            Image.open(image_path).convert("RGB").save(
                fixed_img,
                "JPEG",
                quality=95
            )

            print("üñº Using image:", fixed_img)

            cmd = [
                FFMPEG, "-y",
                "-loop", "1",
                "-framerate", "30",
                "-t", duration_str,
                "-i", fixed_img,
                "-i", wav_path,
                "-vf",
                "scale=1080:1080:force_original_aspect_ratio=decrease,"
                "pad=1080:1080:(ow-iw)/2:(oh-ih)/2,format=yuv420p",
                "-c:v", "libx264",
                "-pix_fmt", "yuv420p",
                "-movflags", "+faststart",
                "-c:a", "aac",
                "-shortest",
                mp4_path
            ]

        else:
            print("üéû Black background")

            cmd = [
                FFMPEG, "-y",
                "-f", "lavfi",
                "-i", f"color=c=black:s=1080x1080:r=30:d={duration_str}",
                "-i", wav_path,
                "-c:v", "libx264",
                "-pix_fmt", "yuv420p",
                "-movflags", "+faststart",
                "-c:a", "aac",
                "-shortest",
                mp4_path
            ]

        print("üî• Running:", " ".join(cmd))
        subprocess.run(cmd, check=True)

        if not os.path.exists(mp4_path):
            raise RuntimeError("MP4 not created")

        print("üé¨ MP4 created:", mp4_path)

        job_store.set_done(job_id, mp4_path)
        return mp4_path

    except Exception as e:
        print("‚ùå TASK FAILED:", e)
        job_store.set_error(job_id, str(e))
        raise

